import os
import datetime as dt
import pandas as pd
import numpy as np
import requests
import tarfile
import matplotlib.pyplot as plt
import ast  # Import for parsing dictionary-like strings


class MovieAnalyzer:
    """
    A class to perform three kinds of quick analysis for movie data from CMU dataset. By calling the built-in methods,
    the analyzer object can generate indicated pandas DataFrame, and return plot generated by matplotlib(if possible).
    

    Attributes
    ----------
    data_dir : str
        default directory for storing datasets.
    movie_data_file : str
        default path for storing 'movie.metadata.tsv' extracted from zipped file.
    movies_df: pandas.DataFrame
        DataFrame of movie data loaded from 'movie.metadata.tsv'
    character_data_file : str
        default path for storing character.metadata.tsv extracted from zipped file.
    characters_df : pandas.DataFrame
        DataFrame of character data loaded fron 'character.metadata.tsv' 
    random_movie_index: int
        Index number of the random selected movie from method "randomize"
    random_movie: pandas.Series
        Information of the random selected movie from method "randomize"

    Methods
    -------
    download_and_extract(self):
        A static method inside class to download target dataset
    movie_type(self, N):
        Return a panda.Series showing how many times a genre in top N genres shows up in the database.
    actor_count(self):
        Return a histogram of "number of actors" vs "movie counts". 
    actor_distributions(self, gender, max_height, min_height):
        Return an actor data in pandas.DataFrame under 3 given conditions or plot the distribution of filtered actorData.
    releases(self, genre):
        Return a DataFrame contains year and number of movies released in that year.
    ages(self, scale):
        Return a DataFrame contains year/month and number of actors born in that year/month.
    randomize():
        Randomly select a movie from dataset and store it to attributes
    """

    @staticmethod
    def parse_genres(x):
        """Convert stringified dictionaries into real Python dicts (handle errors safely)"""
        try:
            return ast.literal_eval(x) if isinstance(x, str) else {}
        except (SyntaxError, ValueError):
            return {}

    @staticmethod    
    def download_and_extract():
        """Download dataset if not present and extract it."""
        url = "http://www.cs.cmu.edu/~ark/personas/data/MovieSummaries.tar.gz"
        tar_path = os.path.join("data", "MovieSummaries.tar.gz")

        if not os.path.exists(tar_path):
            print("Downloading dataset...")
            response = requests.get(url, stream=True)
            with open(tar_path, "wb") as file:
                for chunk in response.iter_content(chunk_size=1024):
                    file.write(chunk)

        print("Extracting dataset...")
        with tarfile.open(tar_path, "r:gz") as tar:
            tar.extractall("data/")  # ✅ Extract correctly into 'data/MovieSummaries/'
    
    
    def __init__(self):
        """Initialize the class by checking for dataset and loading it."""
        self.data_dir = "data/MovieSummaries/"
        os.makedirs(self.data_dir, exist_ok=True)

        # Dataset file paths
        self.movie_data_file = os.path.join(self.data_dir, "movie.metadata.tsv")
        self.character_data_file = os.path.join(self.data_dir, "character.metadata.tsv")

        # Check if datasets exist; if not, download and extract them
        if not os.path.exists(self.movie_data_file) or not os.path.exists(
            self.character_data_file
        ):
            self.download_and_extract()

        # Load datasets
        self.movies_df = pd.read_csv(
            self.movie_data_file,
            sep="\t",
            header=None,
            names=[
                "wiki_movie_id",
                "freebase_movie_id",
                "movie_name",
                "release_date",
                "box_office",
                "runtime",
                "languages",
                "countries",
                "genres",
            ],
        )

        self.characters_df = pd.read_csv(
            self.character_data_file,
            sep="\t",
            header=None,
            names=[
                "wiki_movie_id",
                "freebase_movie_id",
                "release_date",
                "character_name",
                "actor_dob",
                "actor_gender",
                "actor_height",
                "actor_ethnicity",
                "actor_name",
                "actor_age",
                "char_actor_map_id",
                "char_id",
                "actor_id",
            ],
        )



    def movie_type(self, N: int = 10) -> pd.DataFrame:
        """
        Returns the N most common movie genres.

        Parameters
        -----------
            self: class
                The MovieAnalyzer class itself
            N: int
                Show only top N genre

        Returns
        --------
            pandas.DataFrame: The movie type counts data

        """
        if not isinstance(N, int):
            raise ValueError("N must be an integer.")

        self.movies_df["genres"] = self.movies_df["genres"].apply(self.parse_genres)

        # Extract genre names
        all_genres = []
        for genre_dict in self.movies_df["genres"].dropna():
            if isinstance(genre_dict, dict):
                all_genres.extend(genre_dict.values())  # Extract genre names

        # Create a DataFrame counting occurrences of each genre
        genre_counts = (
            pd.DataFrame({"Movie_Type": all_genres}).value_counts().reset_index()
        )
        genre_counts.columns = ["Movie_Type", "Count"]

        return genre_counts.head(N)

    def actor_count(self) -> pd.DataFrame:
        """
        Plots a histogram data of actors per movie.
        
        Returns
        -----------
        matplotlib.pyplot.figure: A figure showing the histogram

        """
        actor_counts = (
            self.characters_df.groupby("wiki_movie_id")
            .size()
            .value_counts()
            .reset_index()
        )
        actor_counts.columns = ["Number_of_Actors", "Movie_Count"]
        return actor_counts

    def actor_distributions(
        self,
        gender: str = "All",
        max_height: float = 2.5,
        min_height: float = 1.0,
        plot: bool = False,
    ) -> pd.DataFrame:
        """
        Calculate a non-duplicated actor data with actors' name, gender and height under three search conditions. 
        Set `plot` to true to plot histogram.

        Parameters
        -----------
        self: class
            The MovieAnalyzer class itself
        gender: str
            "All" or specific gender ("Male", "Female", etc.).
        max_height: float
            Maximum actor height.
        min_height: float 
            Minimum actor height.
        plot: boolean
            If True, plots the height distribution.
        
        Returns
        -------- 
            pandas.DataFrame: Filtered DataFrame with actor names, gender, and height.
            matplotlib.pylot.figure: A figure showing the distribution in histogram

        Raises ValueError: If gender is not a string or height values are not numeric.
        """

        # Validate input types
        if not isinstance(gender, str):
            raise ValueError("Gender must be a string ('All', 'Male', 'Female', etc.).")

        if not isinstance(max_height, (int, float)) or not isinstance(
            min_height, (int, float)
        ):
            raise ValueError("Height values must be numeric.")

        if max_height < min_height:
            raise ValueError("max_height must be greater than min_height.")

        # Convert 'M' -> 'Male', 'F' -> 'Female' in the dataset
        self.characters_df["actor_gender"] = self.characters_df["actor_gender"].replace(
            {"M": "Male", "F": "Female"}
        )

        # Filter dataset based on height
        df = self.characters_df.dropna(
            subset=["actor_height"]
        )  # Remove missing heights
        df = df[(df["actor_height"] >= min_height) & (df["actor_height"] <= max_height)]

        # Get distinct non-missing gender values
        valid_genders = df["actor_gender"].dropna().unique().tolist()

        # Validate gender input
        if gender != "All" and gender not in valid_genders:
            raise ValueError(f"Invalid gender. Choose from {valid_genders} or 'All'.")

        # Filter by gender if not "All"
        if gender != "All":
            df = df[df["actor_gender"] == gender]

        # Plot if requested
        if plot:
            plt.figure(figsize=(8, 5))
            plt.hist(
                df["actor_height"].dropna(),
                bins=20,
                alpha=0.7,
                color="skyblue",
                edgecolor="black",
            )
            plt.xlabel("Height (m)")
            plt.ylabel("Frequency")
            plt.title(f"Actor Height Distribution - Gender: {gender}")
            plt.grid(axis="y", linestyle="--", alpha=0.7)

            # ✅ Ensure the plot is rendered in Streamlit
            import streamlit as st

            st.pyplot(plt)

        return df[["actor_name", "actor_gender", "actor_height"]]
    
    def releases(self, genre: str = None) -> pd.DataFrame:
        """
        Generate a pandas DataFrame showing how many movies are released every year, filtered to a specific genre, when 
        a genre is selected.

        Parameters
        ----------
        genre: str
            Selected genre to be focused on

        Returns
        -------
        pandas.DataFrame: Release year and number of movies released in that year

        """
        # Use static method to parse genres and form lists
        self.movies_df["genres"] = self.movies_df["genres"].apply(self.parse_genres)
        self.movies_df["genres"] = self.movies_df["genres"].apply(lambda x: list(x.values()))

        # Extract year from "Release Date"
        self.movies_df["release_year"] = pd.to_datetime(self.movies_df["release_date"], format="%Y-%m-%d", errors="coerce")
        self.movies_df["release_year"] = self.movies_df["release_year"].dt.strftime("%Y")
        # If no genre given, group movies directly
        if genre == None:
            releases_grouped = self.movies_df.groupby("release_year")

        # if a genre is given, search for matched movies then group them
        else:
            releases_grouped = self.movies_df[self.movies_df["genres"].apply(lambda x: genre in x)].groupby("release_year")

        releases = releases_grouped.size().reset_index()
        releases_columns = {"release_year": "Release Year", 0: "Number of Movies"}

        return releases.rename(columns=releases_columns)
    
    def ages(self, scale: str = "Y"):
        """
        Generate a pandas DataFrame showing how many births each year or each month. Scale is controled by parameter 
        "scale", by default set to "Y"

        Parameters
        ---------
        scale: str
            Set scale to "Y"(Year) or "M"(Month), any other input will be seen as "Y".

        Returns
        -------
        pandas.DataFrame: Year/Month and number of births in that year/Month

        """
        if scale != "Y" and scale != "M":
            scale = "Y"
        
        # Extract year and month from "actor_dob"
        self.characters_df["actor_birth_year"] = pd.to_datetime(self.characters_df["actor_dob"], format="%Y-%m-%d", errors="coerce")
        self.characters_df["actor_birth_year"] = self.characters_df["actor_birth_year"].dt.strftime("%Y")

        self.characters_df["actor_birth_month"] = pd.to_datetime(self.characters_df["actor_dob"], format="%Y-%m-%d", errors="coerce")
        self.characters_df["actor_birth_month"] = self.characters_df["actor_birth_month"].dt.strftime("%B")

        # scale set to "Y"
        if scale == "Y":
            ages_grouped = self.characters_df.groupby("actor_birth_year")
            ages = ages_grouped.size().reset_index()

            ages.columns = ["Year", "Number of Births"]

        # if scale set to "M"
        if scale == "M":
            month_order = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
            ages_grouped = self.characters_df.groupby("actor_birth_month")
            ages = ages_grouped.size().reset_index()

            ages["actor_birth_month"] = pd.Categorical(ages["actor_birth_month"], categories=month_order, ordered=True) 
            ages.columns = ["Month", "Number of Births"]

            ages = ages.sort_values("Month").reset_index(drop=True)

        return ages
    
    def randomize(self):
        """
        Randomly select an entry from the dataset. The method does not return anything, instead the movie entry and its 
        index are stored to respective attributes of class
        """
        for x in ["languages", "countries", "genres"]:
            self.movies_df[x] = self.movies_df[x].apply(self.parse_genres)
            self.movies_df[x] = self.movies_df[x].apply(lambda x: list(x.values()))

        self.movies_df["release_date"] = pd.to_datetime(self.movies_df["release_date"], format="%Y-%m-%d", errors="coerce").dt.date

        self.movies_df.drop(columns=["wiki_movie_id","freebase_movie_id", "box_office", "runtime"], inplace=True)
        self.movies_df.dropna(inplace=True)
        
        self.random_movie_index = np.random.randint(0, self.movies_df.shape[0])
        self.random_movie = self.movies_df.iloc[self.random_movie_index]
